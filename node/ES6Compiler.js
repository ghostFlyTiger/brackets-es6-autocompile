/*jshint node: true, evil: true */
'use strict';

var path = require('path');
var fs = require('fs');
var mkpath = require('mkpath');
var babel = require("babel");

function readOptions(content) {
  var firstLine = content.substr(0, content.indexOf('\n'));
  var match = /^\s*\/\/\s*(.+)/.exec(firstLine);
  var options = {};

  if (!match) {
    return options;
  }

  match[1].split(',').forEach(function (item) {
    var key, value, i = item.indexOf(':');
    if (i < 0) {
      return;
    }
    key = item.substr(0, i).trim();
    value = item.substr(i + 1).trim();
    if (value.match(/^(true|false|undefined|null|[0-9]+)$/)) {
      value = eval(value);
    }
    options[key] = value;
  });
  return options;
}

// makes a file in a path where directories may or may not have existed before
function mkfile(filepath, content, callback) {
  mkpath(path.dirname(filepath), function (err) {
    if (err) {
      return callback ? callback(err) : undefined;
    }
    fs.writeFile(filepath, content, callback);
  });
}

// compile the given es6 file
function compile(es6File, callback) {

  fs.readFile(es6File, function (err, buffer) {
    if (err) {
      return callback(err);
    }

    var content = buffer.toString();
    var options = readOptions(content);
    var es6Path = path.dirname(es6File);
    var jsFilename;
    var jsFile;

    // main is set: compile the referenced file instead
    if (options.main) {
      es6File = path.resolve(es6Path, options.main);
      return compile(es6File, callback);
    }

    // out is null or false: do not compile
    if (options.out === null || options.out === false) {
      return callback();
    }

    // out is set: output to the given file name
    if (options.out) {
      jsFilename = options.out;
      if (path.extname(jsFilename) === '') {
        jsFilename += '.js';
      }
      delete options.out;
    } else {
      jsFilename = path.basename(es6File);
      jsFilename = jsFilename.substr(0, jsFilename.length - path.extname(jsFilename).length) + '.js';
    }
    jsFile = path.resolve(es6Path, jsFilename);
    

    // set the path
    options.paths = [es6Path];
    options.filename = es6File;
    // options.rootpath = es6Path;

    // plugins
    options.plugins = [];

    // compile !
    var output;
    try {
      output = babel.transform(content, {filename: "TEST"});
    } catch (err) {
      err.filepath = es6File;
      return callback(err);
    }
    
    var js = output.code;

    // add version tag
    if (!options.compress && !options.cleancss) {
      js = '/* Generated by Babel.js */\n' + js;
    }
    
    // write output
    mkfile(jsFile, js, function (err) {
      if (err) {
        return callback(err);
      }

      // write source map
      if (output.map && options.sourceMapFilename) {
        mkfile(options.sourceMapFilename, output.map, function (err) {
          if (err) {
            return callback(err);
          }
          callback(null, { filepath: jsFile, output: js });
        });
      } else {
        callback(null, { filepath: jsFile, output: js });
      }
    });

  });

}

// set up service for brackets
function init(DomainManager) {
  if (!DomainManager.hasDomain('ES6Compiler')) {
    DomainManager.registerDomain('ES6Compiler', { major: 1, minor: 0 });
  }
  DomainManager.registerCommand(
    'ES6Compiler', // domain name
    'compile', // command name
    compile, // command handler function
    true, // this command is asynchronous
    'Compiles a .es6 file to a .js file', ['es6Path'], // path parameters
    null);
}

exports.init = init;
